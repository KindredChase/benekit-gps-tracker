<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>íƒ„ì  íŠ¸ ë§ˆìŠ¤í„° ì±Œë¦°ì§€ - ê³ ê¸‰ GPX ë¶„ì„ê¸°</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        .upload-section {
            padding: 40px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }
        
        .drop-zone {
            border: 3px dashed #3498db;
            border-radius: 15px;
            padding: 50px;
            background: #f8f9fa;
            transition: all 0.3s ease;
            cursor: pointer;
            margin-bottom: 25px;
        }
        
        .drop-zone:hover, .drop-zone.dragover {
            border-color: #2980b9;
            background: #e3f2fd;
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(52, 152, 219, 0.2);
        }
        
        .upload-text {
            font-size: 1.5em;
            color: #2c3e50;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .upload-subtitle {
            color: #7f8c8d;
            font-size: 1.1em;
            line-height: 1.5;
        }
        
        .btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 18px 35px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 25px rgba(52, 152, 219, 0.3);
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .results {
            display: none;
            padding: 40px;
        }
        
        .result-card {
            background: #ffffff;
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 25px;
            border: 1px solid #e9ecef;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        }
        
        .result-title {
            font-size: 1.6em;
            font-weight: bold;
            margin-bottom: 20px;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .verification-result {
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            text-align: center;
            border: 2px solid;
        }
        
        .verification-authentic {
            background: linear-gradient(135deg, #d4edda, #c3e6cb);
            border-color: #28a745;
            color: #155724;
        }
        
        .verification-suspicious {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            border-color: #ffc107;
            color: #856404;
        }
        
        .verification-fake {
            background: linear-gradient(135deg, #f8d7da, #f5c6cb);
            border-color: #dc3545;
            color: #721c24;
        }
        
        .score-display {
            font-size: 3em;
            font-weight: bold;
            margin: 20px 0;
        }
        
        .fpt-score {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            border: 3px solid #28a745;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            margin-bottom: 25px;
        }
        
        .fpt-score .score {
            font-size: 3.5em;
            font-weight: bold;
            color: #28a745;
            margin: 15px 0;
        }
        
        #map {
            height: 500px;
            width: 100%;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .elevation-chart-container {
            margin-bottom: 30px;
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
        }
        
        .elevation-chart-container h3 {
            margin-bottom: 20px;
            color: #2c3e50;
            font-size: 1.4em;
        }
        
        .segment-analysis {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
        }
        
        .segment-analysis h3 {
            color: #856404;
            margin-bottom: 20px;
            font-size: 1.4em;
        }
        
        .segment-item {
            display: grid;
            grid-template-columns: 80px 1fr 100px 100px 80px 100px;
            gap: 15px;
            padding: 15px;
            background: white;
            border-radius: 10px;
            margin-bottom: 10px;
            align-items: center;
            font-size: 0.95em;
        }
        
        .segment-header {
            font-weight: bold;
            background: #ffc107;
            color: white;
        }
        
        .uphill-summary {
            background: linear-gradient(135deg, #d1ecf1, #bee5eb);
            border: 3px solid #17a2b8;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            margin-bottom: 25px;
        }
        
        .uphill-summary h3 {
            color: #0c5460;
            margin-bottom: 15px;
            font-size: 1.4em;
        }
        
        .uphill-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .uphill-stat {
            background: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }
        
        .uphill-stat .value {
            font-size: 2em;
            font-weight: bold;
            color: #17a2b8;
            display: block;
            margin-bottom: 8px;
        }
        
        .uphill-stat .label {
            font-size: 1em;
            color: #0c5460;
            font-weight: 500;
        }
        
        .data-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }
        
        .data-item {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            border-left: 5px solid #3498db;
            transition: transform 0.2s ease;
        }
        
        .data-item:hover {
            transform: translateX(5px);
        }
        
        .data-label {
            font-size: 0.9em;
            color: #6c757d;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .data-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 25px;
            border-radius: 15px;
            border: 2px solid #dc3545;
            text-align: center;
            margin: 25px 0;
            font-size: 1.1em;
        }
        
        .file-input {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”ï¸ íƒ„ì  íŠ¸ ë§ˆìŠ¤í„° ì±Œë¦°ì§€</h1>
            <p>ê³ ê¸‰ ë“±ì‚° GPX íŒŒì¼ ë¶„ì„ - ì§€ë„, ê³ ë„í‘œ, êµ¬ê°„ ë¶„ì„, ì˜¤ë¥´ë§‰ ì „ìš© ê±°ë¦¬</p>
        </div>
        
        <div class="upload-section">
            <div class="drop-zone" id="dropZone">
                <div class="upload-text">ğŸ“ GPX íŒŒì¼ì„ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì„ íƒ</div>
                <div class="upload-subtitle">
                    ë“±ì‚° ê¸°ë¡ GPX íŒŒì¼ì„ ì—…ë¡œë“œí•˜ë©´ ì§€ë„, ê³ ë„í‘œ, êµ¬ê°„ë³„ ë¶„ì„ì„ ì œê³µí•©ë‹ˆë‹¤<br>
                    íƒ„ì  íŠ¸ ë§ˆìŠ¤í„° ì±Œë¦°ì§€ ê·œì¹™ ì¤€ìˆ˜ ì—¬ë¶€ì™€ FPT ì ìˆ˜ë„ í™•ì¸í•˜ì„¸ìš”
                </div>
            </div>
            <input type="file" id="gpxFile" class="file-input" accept=".gpx" multiple>
            
            <button class="btn" id="sampleBtn">
                ğŸ“ ìƒ˜í”Œ ë°ì´í„°ë¡œ í…ŒìŠ¤íŠ¸í•´ë³´ê¸°
            </button>
        </div>
        
        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <div style="font-size: 1.2em; color: #2c3e50;">GPX íŒŒì¼ ë¶„ì„ ì¤‘...</div>
            <div style="color: #7f8c8d; margin-top: 10px;">ì§€ë„ ìƒì„± ë° ìƒì„¸ ë¶„ì„ì„ ì§„í–‰í•©ë‹ˆë‹¤</div>
        </div>
        
        <div class="results" id="results"></div>
    </div>

    <script>
        // ì „ì—­ ë³€ìˆ˜
        let currentMap = null;
        let currentElevationChart = null;
        
        // DOM ìš”ì†Œ
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('gpxFile');
        const sampleBtn = document.getElementById('sampleBtn');
        const loading = document.getElementById('loading');
        const results = document.getElementById('results');
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', handleDragOver);
        dropZone.addEventListener('dragleave', handleDragLeave);
        dropZone.addEventListener('drop', handleDrop);
        fileInput.addEventListener('change', handleFileSelect);
        sampleBtn.addEventListener('click', loadSampleData);
        
        function handleDragOver(e) {
            e.preventDefault();
            dropZone.classList.add('dragover');
        }
        
        function handleDragLeave() {
            dropZone.classList.remove('dragover');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                processFiles(files);
            }
        }
        
        function handleFileSelect(e) {
            if (e.target.files.length > 0) {
                processFiles(e.target.files);
            }
        }
        
        // íŒŒì¼ ì²˜ë¦¬
        async function processFiles(files) {
            loading.style.display = 'block';
            results.style.display = 'none';
            
            const analysisResults = [];
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                try {
                    const gpxContent = await readFileAsText(file);
                    const analysis = await analyzeGPXFile(gpxContent, file.name);
                    analysisResults.push(analysis);
                } catch (error) {
                    console.error('íŒŒì¼ ë¶„ì„ ì˜¤ë¥˜:', error);
                    analysisResults.push({
                        filename: file.name,
                        error: error.message,
                        isValid: false
                    });
                }
            }
            
            displayResults(analysisResults);
            
            loading.style.display = 'none';
            results.style.display = 'block';
        }
        
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = () => reject(new Error('íŒŒì¼ ì½ê¸° ì‹¤íŒ¨'));
                reader.readAsText(file);
            });
        }
        
        async function analyzeGPXFile(gpxContent, filename) {
            console.log('=== GPX ë¶„ì„ ì‹œì‘ ===', filename);
            
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(gpxContent, "text/xml");
            
            const parseError = xmlDoc.getElementsByTagName("parsererror");
            if (parseError.length > 0) {
                throw new Error('GPX íŒŒì¼ íŒŒì‹± ì˜¤ë¥˜');
            }
            
            const trackpoints = extractTrackpoints(xmlDoc);
            console.log('ì¶”ì¶œëœ íŠ¸ë™í¬ì¸íŠ¸:', trackpoints.length);
            
            if (trackpoints.length === 0) {
                throw new Error('ìœ íš¨í•œ íŠ¸ë™í¬ì¸íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤');
            }
            
            const dataIntegrity = analyzeDataIntegrity(trackpoints);
            
            let detailedAnalysis = null;
            let fptScore = null;
            let challengeValidation = null;
            let segmentAnalysis = null;
            let uphillAnalysis = null;
            
            if (dataIntegrity.isValid) {
                detailedAnalysis = performDetailedAnalysis(trackpoints);
                fptScore = calculateFPTScore(detailedAnalysis);
                challengeValidation = validateChallengeRules(trackpoints, detailedAnalysis);
                segmentAnalysis = analyzeSegments(trackpoints);
                uphillAnalysis = calculateUphillDistance(trackpoints);
            }
            
            return {
                filename: filename,
                trackpointCount: trackpoints.length,
                trackpoints: trackpoints,
                dataIntegrity: dataIntegrity,
                detailedAnalysis: detailedAnalysis,
                fptScore: fptScore,
                challengeValidation: challengeValidation,
                segmentAnalysis: segmentAnalysis,
                uphillAnalysis: uphillAnalysis,
                isValid: dataIntegrity.isValid
            };
        }
        
        function extractTrackpoints(xmlDoc) {
            const trackpoints = [];
            
            const tracks = xmlDoc.getElementsByTagName('trk');
            for (let i = 0; i < tracks.length; i++) {
                const segments = tracks[i].getElementsByTagName('trkseg');
                for (let j = 0; j < segments.length; j++) {
                    const points = segments[j].getElementsByTagName('trkpt');
                    for (let k = 0; k < points.length; k++) {
                        const point = extractPointData(points[k]);
                        if (point) trackpoints.push(point);
                    }
                }
            }
            
            if (trackpoints.length < 10) {
                const waypoints = xmlDoc.getElementsByTagName('wpt');
                for (let i = 0; i < waypoints.length; i++) {
                    const point = extractPointData(waypoints[i]);
                    if (point) trackpoints.push(point);
                }
            }
            
            trackpoints.sort((a, b) => {
                if (!a.time || !b.time) return 0;
                return new Date(a.time) - new Date(b.time);
            });
            
            return trackpoints;
        }
        
        function extractPointData(pointElement) {
            const lat = parseFloat(pointElement.getAttribute('lat'));
            const lon = parseFloat(pointElement.getAttribute('lon'));
            
            if (isNaN(lat) || isNaN(lon)) return null;
            
            let elevation = null;
            const eleElement = pointElement.getElementsByTagName('ele')[0];
            if (eleElement) {
                elevation = parseFloat(eleElement.textContent);
            }
            
            let time = null;
            const timeElement = pointElement.getElementsByTagName('time')[0];
            if (timeElement) {
                try {
                    time = new Date(timeElement.textContent).toISOString();
                } catch (e) {
                    console.warn('ì‹œê°„ íŒŒì‹± ì‹¤íŒ¨:', timeElement.textContent);
                }
            }
            
            return {
                latitude: lat,
                longitude: lon,
                elevation: elevation,
                time: time
            };
        }
        
        function analyzeDataIntegrity(trackpoints) {
            const totalPoints = trackpoints.length;
            let validTimeCount = 0;
            let validElevationCount = 0;
            let validSequenceCount = 0;
            
            for (let i = 0; i < trackpoints.length; i++) {
                if (trackpoints[i].time) {
                    validTimeCount++;
                    if (i > 0 && trackpoints[i-1].time) {
                        const time1 = new Date(trackpoints[i-1].time);
                        const time2 = new Date(trackpoints[i].time);
                        if (time2 > time1) {
                            validSequenceCount++;
                        }
                    }
                }
                if (trackpoints[i].elevation !== null && !isNaN(trackpoints[i].elevation)) {
                    validElevationCount++;
                }
            }
            
            const timeRatio = validTimeCount / totalPoints;
            const elevationRatio = validElevationCount / totalPoints;
            const sequenceRatio = validSequenceCount / Math.max(1, validTimeCount - 1);
            
            let isValid = false;
            let suspicionScore = 0;
            let verdict = "";
            let issues = [];
            
            if (timeRatio < 0.1) {
                suspicionScore += 90;
                issues.push("ì‹œê°„ ì •ë³´ ê±°ì˜ ì—†ìŒ (í”„ë¡œê·¸ë¨ ìƒì„± í™•ì‹¤)");
            } else if (timeRatio < 0.5) {
                suspicionScore += 60;
                issues.push("ì‹œê°„ ì •ë³´ ë¶€ì¡± (ë°ì´í„° ë¬´ê²°ì„± ì˜ì‹¬)");
            }
            
            if (sequenceRatio < 0.8 && validTimeCount > 1) {
                suspicionScore += 50;
                issues.push("ì‹œê°„ ìˆœì„œ ë¶ˆì¼ì¹˜ (ë°ì´í„° ì¡°ì‘ ì˜ì‹¬)");
            }
            
            if (elevationRatio < 0.3) {
                suspicionScore += 30;
                issues.push("ê³ ë„ ì •ë³´ ë¶€ì¡±");
            }
            
            if (suspicionScore >= 80) {
                verdict = "ğŸš¨ ê°€ì§œ íŒŒì¼ í™•ì‹¤";
                isValid = false;
            } else if (suspicionScore >= 40) {
                verdict = "âš ï¸ ì˜ì‹¬ìŠ¤ëŸ¬ìš´ íŒŒì¼";
                isValid = false;
            } else {
                verdict = "âœ… ì‹¤ì œ ê¸°ë¡";
                isValid = true;
            }
            
            return {
                isValid: isValid,
                suspicionScore: suspicionScore,
                verdict: verdict,
                issues: issues,
                timeRatio: (timeRatio * 100).toFixed(1),
                elevationRatio: (elevationRatio * 100).toFixed(1),
                sequenceRatio: (sequenceRatio * 100).toFixed(1),
                validTimeCount: validTimeCount,
                validElevationCount: validElevationCount
            };
        }
        
        function calculateDistance(point1, point2) {
            const R = 6371;
            const lat1 = point1.latitude * Math.PI / 180;
            const lon1 = point1.longitude * Math.PI / 180;
            const lat2 = point2.latitude * Math.PI / 180;
            const lon2 = point2.longitude * Math.PI / 180;
            
            const dLat = lat2 - lat1;
            const dLon = lon2 - lon1;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1) * Math.cos(lat2) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function performDetailedAnalysis(trackpoints) {
            let totalDistance = 0;
            let totalElevationGain = 0;
            let totalElevationLoss = 0;
            let movingTime = 0;
            const speeds = [];
            
            for (let i = 1; i < trackpoints.length; i++) {
                const prev = trackpoints[i-1];
                const curr = trackpoints[i];
                
                const distance = calculateDistance(prev, curr);
                totalDistance += distance;
                
                if (prev.elevation !== null && curr.elevation !== null) {
                    const elevationChange = curr.elevation - prev.elevation;
                    if (Math.abs(elevationChange) > 0.5) {
                        if (elevationChange > 0) {
                            totalElevationGain += elevationChange;
                        } else {
                            totalElevationLoss += Math.abs(elevationChange);
                        }
                    }
                }
                
                if (prev.time && curr.time) {
                    const time1 = new Date(prev.time);
                    const time2 = new Date(curr.time);
                    const timeDiff = (time2 - time1) / 1000;
                    
                    if (timeDiff > 0 && timeDiff < 3600) {
                        movingTime += timeDiff;
                        if (distance > 0) {
                            const speed = (distance * 3600) / timeDiff;
                            if (speed < 100) {
                                speeds.push(speed);
                            }
                        }
                    }
                }
            }
            
            const elevations = trackpoints
                .map(p => p.elevation)
                .filter(e => e !== null && !isNaN(e));
            
            const maxElevation = elevations.length > 0 ? Math.max(...elevations) : 0;
            const minElevation = elevations.length > 0 ? Math.min(...elevations) : 0;
            const averageSpeed = speeds.length > 0 ? speeds.reduce((a, b) => a + b, 0) / speeds.length : 0;
            
            return {
                totalDistance: totalDistance,
                totalElevationGain: totalElevationGain,
                totalElevationLoss: totalElevationLoss,
                movingTime: movingTime,
                maxElevation: maxElevation,
                minElevation: minElevation,
                averageSpeed: averageSpeed,
                speedData: speeds
            };
        }
        
        function calculateFPTScore(analysis) {
            if (!analysis) return null;
            
            const distance = analysis.totalDistance;
            const elevationGain = analysis.totalElevationGain;
            
            let fptScore = Math.floor(distance * 10);
            
            if (elevationGain > 100) {
                fptScore += Math.floor(elevationGain / 10);
            }
            
            return {
                score: fptScore,
                breakdown: {
                    distance: Math.floor(distance * 10),
                    elevation: Math.floor(elevationGain / 10),
                    bonus: 0
                }
            };
        }
        
        function validateChallengeRules(trackpoints, analysis) {
            const rules = [];
            
            rules.push({
                name: "ìµœì†Œ ê±°ë¦¬ 5km ì´ìƒ",
                passed: analysis.totalDistance >= 5,
                actual: analysis.totalDistance.toFixed(2) + "km",
                required: "5km ì´ìƒ"
            });
            
            rules.push({
                name: "ìµœì†Œ ê³ ë„ ìƒìŠ¹ 300m ì´ìƒ",
                passed: analysis.totalElevationGain >= 300,
                actual: Math.round(analysis.totalElevationGain) + "m",
                required: "300m ì´ìƒ"
            });
            
            const movingTimeHours = analysis.movingTime / 3600;
            rules.push({
                name: "ìµœì†Œ Moving Time 2ì‹œê°„ ì´ìƒ",
                passed: movingTimeHours >= 2,
                actual: formatDuration(analysis.movingTime),
                required: "2ì‹œê°„ ì´ìƒ"
            });
            
            rules.push({
                name: "í‰ê·  ì†ë„ ì ì •ì„±",
                passed: analysis.averageSpeed >= 1 && analysis.averageSpeed <= 15,
                actual: analysis.averageSpeed.toFixed(1) + "km/h",
                required: "1-15km/h ë²”ìœ„"
            });
            
            const allPassed = rules.every(rule => rule.passed);
            
            return {
                allRulesPassed: allPassed,
                rules: rules,
                overallStatus: allPassed ? "âœ… ëª¨ë“  ê·œì¹™ í†µê³¼" : "âŒ ì¼ë¶€ ê·œì¹™ ë¯¸ë‹¬"
            };
        }
        
        // 1km êµ¬ê°„ë³„ ë¶„ì„
        function analyzeSegments(trackpoints) {
            const segments = [];
            let currentDistance = 0;
            let segmentStart = 0;
            let segmentDistance = 0;
            let segmentStartTime = null;
            let segmentStartElevation = null;
            
            for (let i = 1; i < trackpoints.length; i++) {
                const prev = trackpoints[i-1];
                const curr = trackpoints[i];
                
                const distance = calculateDistance(prev, curr);
                currentDistance += distance;
                segmentDistance += distance;
                
                if (segmentStartTime === null && prev.time) {
                    segmentStartTime = new Date(prev.time);
                }
                if (segmentStartElevation === null && prev.elevation !== null) {
                    segmentStartElevation = prev.elevation;
                }
                
                // 1kmë§ˆë‹¤ êµ¬ê°„ ìƒì„±
                if (segmentDistance >= 1.0) {
                    const segmentEndTime = curr.time ? new Date(curr.time) : null;
                    const segmentEndElevation = curr.elevation;
                    
                    let duration = 0;
                    let averageSpeed = 0;
                    let elevationChange = 0;
                    
                    if (segmentStartTime && segmentEndTime) {
                        duration = (segmentEndTime - segmentStartTime) / 1000;
                        averageSpeed = duration > 0 ? (segmentDistance * 3600) / duration : 0;
                    }
                    
                    if (segmentStartElevation !== null && segmentEndElevation !== null) {
                        elevationChange = segmentEndElevation - segmentStartElevation;
                    }
                    
                    segments.push({
                        segmentNumber: segments.length + 1,
                        startKm: (currentDistance - segmentDistance).toFixed(1),
                        endKm: currentDistance.toFixed(1),
                        distance: segmentDistance.toFixed(2),
                        duration: duration,
                        averageSpeed: averageSpeed,
                        elevationChange: elevationChange,
                        startElevation: segmentStartElevation,
                        endElevation: segmentEndElevation
                    });
                    
                    // ë‹¤ìŒ êµ¬ê°„ ì¤€ë¹„
                    segmentDistance = 0;
                    segmentStartTime = segmentEndTime;
                    segmentStartElevation = segmentEndElevation;
                }
            }
            
            // ë§ˆì§€ë§‰ êµ¬ê°„ (1km ë¯¸ë§Œ)
            if (segmentDistance > 0.1) {
                const lastPoint = trackpoints[trackpoints.length - 1];
                const segmentEndTime = lastPoint.time ? new Date(lastPoint.time) : null;
                const segmentEndElevation = lastPoint.elevation;
                
                let duration = 0;
                let averageSpeed = 0;
                let elevationChange = 0;
                
                if (segmentStartTime && segmentEndTime) {
                    duration = (segmentEndTime - segmentStartTime) / 1000;
                    averageSpeed = duration > 0 ? (segmentDistance * 3600) / duration : 0;
                }
                
                if (segmentStartElevation !== null && segmentEndElevation !== null) {
                    elevationChange = segmentEndElevation - segmentStartElevation;
                }
                
                segments.push({
                    segmentNumber: segments.length + 1,
                    startKm: (currentDistance - segmentDistance).toFixed(1),
                    endKm: currentDistance.toFixed(1),
                    distance: segmentDistance.toFixed(2),
                    duration: duration,
                    averageSpeed: averageSpeed,
                    elevationChange: elevationChange,
                    startElevation: segmentStartElevation,
                    endElevation: segmentEndElevation
                });
            }
            
            return segments;
        }
        
        // ì˜¤ë¥´ë§‰ êµ¬ê°„ë§Œ í•©ì‚°
        function calculateUphillDistance(trackpoints) {
            let uphillDistance = 0;
            let totalUphillElevation = 0;
            let uphillSegments = [];
            let currentUphillStart = null;
            let currentUphillDistance = 0;
            let currentUphillElevation = 0;
            
            const minGradient = 0.02; // 2% ê²½ì‚¬ ì´ìƒì„ ì˜¤ë¥´ë§‰ìœ¼ë¡œ ê°„ì£¼
            
            for (let i = 1; i < trackpoints.length; i++) {
                const prev = trackpoints[i-1];
                const curr = trackpoints[i];
                
                if (prev.elevation !== null && curr.elevation !== null) {
                    const distance = calculateDistance(prev, curr) * 1000; // ë¯¸í„°ë¡œ ë³€í™˜
                    const elevationChange = curr.elevation - prev.elevation;
                    const gradient = distance > 0 ? elevationChange / distance : 0;
                    
                    if (gradient >= minGradient && elevationChange > 0) {
                        // ì˜¤ë¥´ë§‰ êµ¬ê°„
                        if (currentUphillStart === null) {
                            currentUphillStart = i - 1;
                            currentUphillDistance = 0;
                            currentUphillElevation = 0;
                        }
                        
                        uphillDistance += distance / 1000; // kmë¡œ ë‹¤ì‹œ ë³€í™˜
                        currentUphillDistance += distance / 1000;
                        totalUphillElevation += elevationChange;
                        currentUphillElevation += elevationChange;
                    } else {
                        // ì˜¤ë¥´ë§‰ êµ¬ê°„ ì¢…ë£Œ
                        if (currentUphillStart !== null && currentUphillDistance > 0.05) { // 50m ì´ìƒì¸ êµ¬ê°„ë§Œ ê¸°ë¡
                            uphillSegments.push({
                                startIndex: currentUphillStart,
                                endIndex: i - 1,
                                distance: currentUphillDistance,
                                elevationGain: currentUphillElevation,
                                averageGradient: (currentUphillElevation / (currentUphillDistance * 1000) * 100).toFixed(1)
                            });
                        }
                        currentUphillStart = null;
                        currentUphillDistance = 0;
                        currentUphillElevation = 0;
                    }
                }
            }
            
            // ë§ˆì§€ë§‰ ì˜¤ë¥´ë§‰ êµ¬ê°„ ì²˜ë¦¬
            if (currentUphillStart !== null && currentUphillDistance > 0.05) {
                uphillSegments.push({
                    startIndex: currentUphillStart,
                    endIndex: trackpoints.length - 1,
                    distance: currentUphillDistance,
                    elevationGain: currentUphillElevation,
                    averageGradient: (currentUphillElevation / (currentUphillDistance * 1000) * 100).toFixed(1)
                });
            }
            
            return {
                totalUphillDistance: uphillDistance,
                totalUphillElevation: totalUphillElevation,
                uphillSegments: uphillSegments,
                uphillPercentage: trackpoints.length > 1 ? (uphillDistance / calculateTotalDistance(trackpoints) * 100).toFixed(1) : 0
            };
        }
        
        function calculateTotalDistance(trackpoints) {
            let totalDistance = 0;
            for (let i = 1; i < trackpoints.length; i++) {
                totalDistance += calculateDistance(trackpoints[i-1], trackpoints[i]);
            }
            return totalDistance;
        }
        
        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            return hours + "ì‹œê°„ " + minutes + "ë¶„";
        }
        
        function formatTime(seconds) {
            if (seconds < 60) return seconds.toFixed(0) + "ì´ˆ";
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            if (minutes < 60) return minutes + "ë¶„ " + remainingSeconds + "ì´ˆ";
            const hours = Math.floor(minutes / 60);
            const remainingMinutes = minutes % 60;
            return hours + "ì‹œê°„ " + remainingMinutes + "ë¶„";
        }
        
        // ì§€ë„ ìƒì„± í•¨ìˆ˜
        function createMap(trackpoints, containerId) {
            if (trackpoints.length === 0) return null;
            
            // ê¸°ì¡´ ì§€ë„ ì œê±°
            if (currentMap) {
                currentMap.remove();
                currentMap = null;
            }
            
            // ê²½ê³„ ê³„ì‚°
            const lats = trackpoints.map(p => p.latitude);
            const lngs = trackpoints.map(p => p.longitude);
            const minLat = Math.min(...lats);
            const maxLat = Math.max(...lats);
            const minLng = Math.min(...lngs);
            const maxLng = Math.max(...lngs);
            
            // ì§€ë„ ìƒì„±
            const map = L.map(containerId).fitBounds([
                [minLat, minLng],
                [maxLat, maxLng]
            ]);
            
            // íƒ€ì¼ ë ˆì´ì–´ ì¶”ê°€
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors'
            }).addTo(map);
            
            // ê²½ë¡œ ê·¸ë¦¬ê¸°
            const routeCoords = trackpoints.map(p => [p.latitude, p.longitude]);
            const routeLine = L.polyline(routeCoords, {
                color: '#e74c3c',
                weight: 4,
                opacity: 0.8
            }).addTo(map);
            
            // ì‹œì‘ì  ë§ˆì»¤
            L.marker([trackpoints[0].latitude, trackpoints[0].longitude])
                .bindPopup('ğŸ ì‹œì‘ì ')
                .addTo(map);
            
            // ëì  ë§ˆì»¤
            const lastPoint = trackpoints[trackpoints.length - 1];
            L.marker([lastPoint.latitude, lastPoint.longitude])
                .bindPopup('ğŸƒ ëì ')
                .addTo(map);
            
            currentMap = map;
            return map;
        }
        
        // ê³ ë„ ì°¨íŠ¸ ìƒì„± í•¨ìˆ˜
        function createElevationChart(trackpoints, containerId) {
            const canvas = document.getElementById(containerId);
            if (!canvas) return null;
            
            const ctx = canvas.getContext('2d');
            
            // ê¸°ì¡´ ì°¨íŠ¸ ì œê±°
            if (currentElevationChart) {
                currentElevationChart.destroy();
                currentElevationChart = null;
            }
            
            // ê±°ë¦¬ì™€ ê³ ë„ ë°ì´í„° ê³„ì‚°
            let cumulativeDistance = 0;
            const chartData = [];
            
            for (let i = 0; i < trackpoints.length; i++) {
                const point = trackpoints[i];
                
                if (i > 0) {
                    const distance = calculateDistance(trackpoints[i-1], point);
                    cumulativeDistance += distance;
                }
                
                if (point.elevation !== null) {
                    chartData.push({
                        x: cumulativeDistance,
                        y: point.elevation
                    });
                }
            }
            
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'ê³ ë„ (m)',
                        data: chartData,
                        borderColor: '#27ae60',
                        backgroundColor: 'rgba(39, 174, 96, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'ê±°ë¦¬ (km)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'ê³ ë„ (m)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `ê±°ë¦¬: ${context.parsed.x.toFixed(2)}km, ê³ ë„: ${context.parsed.y.toFixed(0)}m`;
                                }
                            }
                        }
                    }
                }
            });
            
            currentElevationChart = chart;
            return chart;
        }
        
        function displayResults(analysisResults) {
            let html = '';
            
            for (const result of analysisResults) {
                html += generateResultCard(result);
            }
            
            results.innerHTML = html;
            
            // ì§€ë„ì™€ ì°¨íŠ¸ ìƒì„± (ì²« ë²ˆì§¸ ìœ íš¨í•œ ê²°ê³¼ì— ëŒ€í•´ì„œë§Œ)
            const validResult = analysisResults.find(r => r.isValid && r.trackpoints);
            if (validResult) {
                // ì§€ë„ ìƒì„±ì„ ìœ„í•œ ë”œë ˆì´
                setTimeout(() => {
                    try {
                        createMap(validResult.trackpoints, 'map');
                        createElevationChart(validResult.trackpoints, 'elevationChart');
                    } catch (error) {
                        console.error('ì§€ë„ ë˜ëŠ” ì°¨íŠ¸ ìƒì„± ì˜¤ë¥˜:', error);
                    }
                }, 100);
            }
        }
        
        function generateResultCard(result) {
            if (result.error) {
                return `
                    <div class="result-card">
                        <div class="result-title">âŒ ${result.filename}</div>
                        <div class="error-message">
                            ì˜¤ë¥˜: ${result.error}
                        </div>
                    </div>
                `;
            }
            
            let html = `
                <div class="result-card">
                    <div class="result-title">ğŸ“Š ${result.filename}</div>
                    
                    <div class="verification-result ${getVerificationClass(result.dataIntegrity)}">
                        <div class="score-display">${result.dataIntegrity.verdict}</div>
                        <p><strong>ì˜ì‹¬ ì ìˆ˜:</strong> ${result.dataIntegrity.suspicionScore}/100</p>
                        <p><strong>íŠ¸ë™í¬ì¸íŠ¸:</strong> ${result.trackpointCount}ê°œ</p>
                        <p><strong>ì‹œê°„ ì •ë³´:</strong> ${result.dataIntegrity.timeRatio}%</p>
                        <p><strong>ê³ ë„ ì •ë³´:</strong> ${result.dataIntegrity.elevationRatio}%</p>
                        ${result.dataIntegrity.issues.length > 0 ? 
                            '<p><strong>ë¬¸ì œì :</strong> ' + result.dataIntegrity.issues.join(', ') + '</p>' : ''}
                    </div>
            `;
            
            if (result.isValid && result.detailedAnalysis) {
                html += generateDetailedResults(result);
            }
            
            html += '</div>';
            return html;
        }
        
        function generateDetailedResults(result) {
            const analysis = result.detailedAnalysis;
            const segments = result.segmentAnalysis || [];
            const uphill = result.uphillAnalysis || {};
            
            let html = '';
            
            // FPT ì ìˆ˜
            if (result.fptScore) {
                html += `
                    <div class="fpt-score">
                        <h3>ğŸ† FPT ì ìˆ˜</h3>
                        <div class="score">${result.fptScore.score}</div>
                        <p>ê±°ë¦¬: ${result.fptScore.breakdown.distance}ì  + ê³ ë„: ${result.fptScore.breakdown.elevation}ì </p>
                    </div>
                `;
            }
            
            // ì§€ë„
            html += `
                <div style="margin-bottom: 30px;">
                    <h3 style="margin-bottom: 15px; color: #2c3e50;">ğŸ—ºï¸ ë“±ì‚° ê²½ë¡œ</h3>
                    <div id="map"></div>
                </div>
            `;
            
            // ê³ ë„ ì°¨íŠ¸
            html += `
                <div class="elevation-chart-container">
                    <h3>ğŸ“ˆ ê³ ë„ ë³€í™” ì°¨íŠ¸</h3>
                    <div style="height: 300px;">
                        <canvas id="elevationChart"></canvas>
                    </div>
                </div>
            `;
            
            // ì˜¤ë¥´ë§‰ êµ¬ê°„ ë¶„ì„
            if (uphill.totalUphillDistance !== undefined) {
                html += `
                    <div class="uphill-summary">
                        <h3>â›°ï¸ ì˜¤ë¥´ë§‰ êµ¬ê°„ ì „ìš© ë¶„ì„</h3>
                        <div class="uphill-stats">
                            <div class="uphill-stat">
                                <span class="value">${uphill.totalUphillDistance.toFixed(2)}</span>
                                <span class="label">ì˜¤ë¥´ë§‰ ê±°ë¦¬ (km)</span>
                            </div>
                            <div class="uphill-stat">
                                <span class="value">${uphill.totalUphillElevation.toFixed(0)}</span>
                                <span class="label">ì˜¤ë¥´ë§‰ ê³ ë„ìƒìŠ¹ (m)</span>
                            </div>
                            <div class="uphill-stat">
                                <span class="value">${uphill.uphillPercentage}%</span>
                                <span class="label">ì˜¤ë¥´ë§‰ ë¹„ìœ¨</span>
                            </div>
                            <div class="uphill-stat">
                                <span class="value">${uphill.uphillSegments.length}</span>
                                <span class="label">ì˜¤ë¥´ë§‰ êµ¬ê°„ ìˆ˜</span>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // 1km êµ¬ê°„ë³„ ë¶„ì„
            if (segments.length > 0) {
                html += `
                    <div class="segment-analysis">
                        <h3>ğŸ“ 1km êµ¬ê°„ë³„ ìƒì„¸ ë¶„ì„</h3>
                        <div class="segment-item segment-header">
                            <div>êµ¬ê°„</div>
                            <div>ê±°ë¦¬ ë²”ìœ„</div>
                            <div>ì†Œìš”ì‹œê°„</div>
                            <div>í‰ê· ì†ë„</div>
                            <div>ê³ ë„ë³€í™”</div>
                            <div>êµ¬ê°„ê±°ë¦¬</div>
                        </div>
                `;
                
                segments.forEach(segment => {
                    html += `
                        <div class="segment-item">
                            <div>${segment.segmentNumber}êµ¬ê°„</div>
                            <div>${segment.startKm} - ${segment.endKm}km</div>
                            <div>${formatTime(segment.duration)}</div>
                            <div>${segment.averageSpeed.toFixed(1)} km/h</div>
                            <div>${segment.elevationChange > 0 ? '+' : ''}${segment.elevationChange.toFixed(0)}m</div>
                            <div>${segment.distance}km</div>
                        </div>
                    `;
                });
                
                html += '</div>';
            }
            
            // ìƒì„¸ ë°ì´í„°
            html += `
                <div class="data-grid">
                    <div class="data-item">
                        <div class="data-label">ì´ ê±°ë¦¬</div>
                        <div class="data-value">${analysis.totalDistance.toFixed(2)} km</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">ê³ ë„ ìƒìŠ¹</div>
                        <div class="data-value">${Math.round(analysis.totalElevationGain)} m</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">ê³ ë„ í•˜ê°•</div>
                        <div class="data-value">${Math.round(analysis.totalElevationLoss)} m</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">ìµœê³  ê³ ë„</div>
                        <div class="data-value">${Math.round(analysis.maxElevation)} m</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">ìµœì € ê³ ë„</div>
                        <div class="data-value">${Math.round(analysis.minElevation)} m</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">í‰ê·  ì†ë„</div>
                        <div class="data-value">${analysis.averageSpeed.toFixed(1)} km/h</div>
                    </div>
                </div>
            `;
            
            // ì±Œë¦°ì§€ ê·œì¹™ ê²€ì¦
            if (result.challengeValidation) {
                const challenge = result.challengeValidation;
                html += `
                    <div style="background: #f8f9ff; border-radius: 15px; padding: 25px; margin-top: 25px; border: 2px solid #6c5ce7;">
                        <h3 style="color: #5a4fcf; margin-bottom: 20px; font-size: 1.4em;">ğŸ¯ íƒ„ì  íŠ¸ ë§ˆìŠ¤í„° ì±Œë¦°ì§€ ê·œì¹™ ê²€ì¦</h3>
                        <div style="text-align: center; margin-bottom: 20px;">
                            <strong style="font-size: 1.2em; color: ${challenge.allRulesPassed ? '#28a745' : '#dc3545'};">
                                ${challenge.overallStatus}
                            </strong>
                        </div>
                        ${challenge.rules.map(rule => `
                            <div style="display: flex; align-items: center; margin-bottom: 15px; padding: 12px; background: white; border-radius: 10px;">
                                <div style="width: 25px; height: 25px; border-radius: 50%; margin-right: 15px; display: flex; align-items: center; justify-content: center; font-weight: bold; color: white; font-size: 0.9em; background: ${rule.passed ? '#28a745' : '#dc3545'};">
                                    ${rule.passed ? 'âœ“' : 'âœ—'}
                                </div>
                                <div>
                                    <strong>${rule.name}</strong><br>
                                    ì‹¤ì œ: ${rule.actual} | ìš”êµ¬: ${rule.required}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            return html;
        }
        
        function getVerificationClass(dataIntegrity) {
            if (dataIntegrity.suspicionScore >= 80) return 'verification-fake';
            if (dataIntegrity.suspicionScore >= 40) return 'verification-suspicious';
            return 'verification-authentic';
        }
        
        // ìƒ˜í”Œ ë°ì´í„° ìƒì„±
        function generateSampleGPX(filename) {
            const startLat = 37.6556;
            const startLon = 126.9924;
            let startEle = 300;
            const startTime = new Date('2024-01-15T09:00:00Z');
            
            let gpxContent = '<?xml version="1.0" encoding="UTF-8"?>\n';
            gpxContent += '<gpx version="1.1" creator="BeneFit App">\n';
            gpxContent += '    <trk>\n';
            gpxContent += '        <name>ì‹¤ì œ ë“±ì‚° ê¸°ë¡</name>\n';
            gpxContent += '        <trkseg>\n';
            
            let lat = startLat;
            let lon = startLon;
            let elevation = startEle;
            let timestamp = new Date(startTime);
            
            const pointCount = 500; // ë” ë§ì€ í¬ì¸íŠ¸ë¡œ ìƒì„¸í•œ ê²½ë¡œ ìƒì„±
            
            for (let i = 0; i < pointCount; i++) {
                const progress = i / pointCount;
                
                // ê³ ë„ ë³€í™” (ì‚°ì˜ í˜•íƒœë¥¼ ì‹œë®¬ë ˆì´ì…˜)
                let elevationTrend = 0;
                if (progress < 0.3) {
                    // ì´ˆë°˜ ì™„ë§Œí•œ ì˜¤ë¥´ë§‰
                    elevationTrend = 2 + Math.random() * 3;
                } else if (progress < 0.6) {
                    // ì¤‘ë°˜ ê°€íŒŒë¥¸ ì˜¤ë¥´ë§‰
                    elevationTrend = 4 + Math.random() * 5;
                } else if (progress < 0.8) {
                    // ì •ìƒ ë¶€ê·¼ ì™„ë§Œí•œ ì˜¤ë¥´ë§‰
                    elevationTrend = 1 + Math.random() * 2;
                } else {
                    // í•˜ì‚° êµ¬ê°„
                    elevationTrend = -(2 + Math.random() * 4);
                }
                
                const terrain = Math.sin(progress * Math.PI * 8) * 2; // ì§€í˜•ì˜ ê¸°ë³µ
                const noise = (Math.random() - 0.5) * 3; // GPS ë…¸ì´ì¦ˆ
                elevation += elevationTrend + terrain + noise;
                
                // ì‹œê°„ ê°„ê²© (15-45ì´ˆ)
                const interval = 15 + Math.random() * 30;
                timestamp = new Date(timestamp.getTime() + interval * 1000);
                
                // ìœ„ì¹˜ ë³€í™”
                const baseSpeed = 2 + Math.random() * 3; // 2-5 km/h
                const distanceKm = (baseSpeed * interval) / 3600;
                const distanceDeg = distanceKm / 111;
                
                const direction = (progress * Math.PI * 3) + (Math.random() - 0.5) * 0.3;
                lat += Math.cos(direction) * distanceDeg + (Math.random() - 0.5) * 0.0001;
                lon += Math.sin(direction) * distanceDeg + (Math.random() - 0.5) * 0.0001;
                
                // ê°€ë” íœ´ì‹ êµ¬ê°„ ì¶”ê°€
                if (Math.random() < 0.02) {
                    for (let rest = 0; rest < 15; rest++) {
                        gpxContent += `            <trkpt lat="${lat.toFixed(6)}" lon="${lon.toFixed(6)}">\n`;
                        gpxContent += `                <ele>${elevation.toFixed(1)}</ele>\n`;
                        gpxContent += `                <time>${timestamp.toISOString()}</time>\n`;
                        gpxContent += `            </trkpt>\n`;
                        timestamp = new Date(timestamp.getTime() + 20000); // 20ì´ˆ ê°„ê²©
                    }
                    continue;
                }
                
                gpxContent += `            <trkpt lat="${lat.toFixed(6)}" lon="${lon.toFixed(6)}">\n`;
                gpxContent += `                <ele>${elevation.toFixed(1)}</ele>\n`;
                gpxContent += `                <time>${timestamp.toISOString()}</time>\n`;
                gpxContent += `            </trkpt>\n`;
            }
            
            gpxContent += '        </trkseg>\n';
            gpxContent += '    </trk>\n';
            gpxContent += '</gpx>';
            
            return {
                filename: filename,
                content: gpxContent
            };
        }
        
        function loadSampleData() {
            console.log('ìƒ˜í”Œ ë°ì´í„° ë¡œë“œ ì‹œì‘');
            
            try {
                const sampleFile = generateSampleGPX('ìƒ˜í”Œ_ë“±ì‚°_ê¸°ë¡.gpx');
                
                loading.style.display = 'block';
                results.style.display = 'none';
                
                setTimeout(async () => {
                    try {
                        const analysis = await analyzeGPXFile(sampleFile.content, sampleFile.filename);
                        displayResults([analysis]);
                    } catch (error) {
                        console.error('ìƒ˜í”Œ ë°ì´í„° ë¶„ì„ ì˜¤ë¥˜:', error);
                        displayResults([{
                            filename: sampleFile.filename,
                            error: error.message,
                            isValid: false
                        }]);
                    }
                    loading.style.display = 'none';
                    results.style.display = 'block';
                }, 1500);
                
            } catch (error) {
                console.error('ìƒ˜í”Œ ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
                alert('ìƒ˜í”Œ ë°ì´í„° ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                loading.style.display = 'none';
            }
        }
        
        console.log('ê³ ê¸‰ GPX ë¶„ì„ê¸° ì´ˆê¸°í™” ì™„ë£Œ');
    </script>
</body>
</html>