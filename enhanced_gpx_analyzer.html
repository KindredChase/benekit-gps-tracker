<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>탄젠트 마스터 챌린지 - 고급 GPX 분석기</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        .upload-section {
            padding: 40px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }
        
        .drop-zone {
            border: 3px dashed #3498db;
            border-radius: 15px;
            padding: 50px;
            background: #f8f9fa;
            transition: all 0.3s ease;
            cursor: pointer;
            margin-bottom: 25px;
        }
        
        .drop-zone:hover, .drop-zone.dragover {
            border-color: #2980b9;
            background: #e3f2fd;
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(52, 152, 219, 0.2);
        }
        
        .upload-text {
            font-size: 1.5em;
            color: #2c3e50;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .upload-subtitle {
            color: #7f8c8d;
            font-size: 1.1em;
            line-height: 1.5;
        }
        
        .btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 18px 35px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 25px rgba(52, 152, 219, 0.3);
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .results {
            display: none;
            padding: 40px;
        }
        
        .result-card {
            background: #ffffff;
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 25px;
            border: 1px solid #e9ecef;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        }
        
        .result-title {
            font-size: 1.6em;
            font-weight: bold;
            margin-bottom: 20px;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .verification-result {
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            text-align: center;
            border: 2px solid;
        }
        
        .verification-authentic {
            background: linear-gradient(135deg, #d4edda, #c3e6cb);
            border-color: #28a745;
            color: #155724;
        }
        
        .verification-suspicious {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            border-color: #ffc107;
            color: #856404;
        }
        
        .verification-fake {
            background: linear-gradient(135deg, #f8d7da, #f5c6cb);
            border-color: #dc3545;
            color: #721c24;
        }
        
        .score-display {
            font-size: 3em;
            font-weight: bold;
            margin: 20px 0;
        }
        
        .fpt-score {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            border: 3px solid #28a745;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            margin-bottom: 25px;
        }
        
        .fpt-score .score {
            font-size: 3.5em;
            font-weight: bold;
            color: #28a745;
            margin: 15px 0;
        }
        
        #map {
            height: 500px;
            width: 100%;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .elevation-chart-container {
            margin-bottom: 30px;
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
        }
        
        .elevation-chart-container h3 {
            margin-bottom: 20px;
            color: #2c3e50;
            font-size: 1.4em;
        }
        
        .segment-analysis {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
        }
        
        .segment-analysis h3 {
            color: #856404;
            margin-bottom: 20px;
            font-size: 1.4em;
        }
        
        .segment-item {
            display: grid;
            grid-template-columns: 80px 1fr 100px 100px 80px 100px;
            gap: 15px;
            padding: 15px;
            background: white;
            border-radius: 10px;
            margin-bottom: 10px;
            align-items: center;
            font-size: 0.95em;
        }
        
        .segment-header {
            font-weight: bold;
            background: #ffc107;
            color: white;
        }
        
        .uphill-summary {
            background: linear-gradient(135deg, #d1ecf1, #bee5eb);
            border: 3px solid #17a2b8;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            margin-bottom: 25px;
        }
        
        .uphill-summary h3 {
            color: #0c5460;
            margin-bottom: 15px;
            font-size: 1.4em;
        }
        
        .uphill-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .uphill-stat {
            background: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }
        
        .uphill-stat .value {
            font-size: 2em;
            font-weight: bold;
            color: #17a2b8;
            display: block;
            margin-bottom: 8px;
        }
        
        .uphill-stat .label {
            font-size: 1em;
            color: #0c5460;
            font-weight: 500;
        }
        
        .data-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }
        
        .data-item {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            border-left: 5px solid #3498db;
            transition: transform 0.2s ease;
        }
        
        .data-item:hover {
            transform: translateX(5px);
        }
        
        .data-label {
            font-size: 0.9em;
            color: #6c757d;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .data-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 25px;
            border-radius: 15px;
            border: 2px solid #dc3545;
            text-align: center;
            margin: 25px 0;
            font-size: 1.1em;
        }
        
        .file-input {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🏔️ 탄젠트 마스터 챌린지</h1>
            <p>고급 등산 GPX 파일 분석 - 지도, 고도표, 구간 분석, 오르막 전용 거리</p>
        </div>
        
        <div class="upload-section">
            <div class="drop-zone" id="dropZone">
                <div class="upload-text">📁 GPX 파일을 드래그하거나 클릭하여 선택</div>
                <div class="upload-subtitle">
                    등산 기록 GPX 파일을 업로드하면 지도, 고도표, 구간별 분석을 제공합니다<br>
                    탄젠트 마스터 챌린지 규칙 준수 여부와 FPT 점수도 확인하세요
                </div>
            </div>
            <input type="file" id="gpxFile" class="file-input" accept=".gpx" multiple>
            
            <button class="btn" id="sampleBtn">
                📝 샘플 데이터로 테스트해보기
            </button>
        </div>
        
        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <div style="font-size: 1.2em; color: #2c3e50;">GPX 파일 분석 중...</div>
            <div style="color: #7f8c8d; margin-top: 10px;">지도 생성 및 상세 분석을 진행합니다</div>
        </div>
        
        <div class="results" id="results"></div>
    </div>

    <script>
        // 전역 변수
        let currentMap = null;
        let currentElevationChart = null;
        
        // DOM 요소
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('gpxFile');
        const sampleBtn = document.getElementById('sampleBtn');
        const loading = document.getElementById('loading');
        const results = document.getElementById('results');
        
        // 이벤트 리스너 설정
        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', handleDragOver);
        dropZone.addEventListener('dragleave', handleDragLeave);
        dropZone.addEventListener('drop', handleDrop);
        fileInput.addEventListener('change', handleFileSelect);
        sampleBtn.addEventListener('click', loadSampleData);
        
        function handleDragOver(e) {
            e.preventDefault();
            dropZone.classList.add('dragover');
        }
        
        function handleDragLeave() {
            dropZone.classList.remove('dragover');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                processFiles(files);
            }
        }
        
        function handleFileSelect(e) {
            if (e.target.files.length > 0) {
                processFiles(e.target.files);
            }
        }
        
        // 파일 처리
        async function processFiles(files) {
            loading.style.display = 'block';
            results.style.display = 'none';
            
            const analysisResults = [];
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                try {
                    const gpxContent = await readFileAsText(file);
                    const analysis = await analyzeGPXFile(gpxContent, file.name);
                    analysisResults.push(analysis);
                } catch (error) {
                    console.error('파일 분석 오류:', error);
                    analysisResults.push({
                        filename: file.name,
                        error: error.message,
                        isValid: false
                    });
                }
            }
            
            displayResults(analysisResults);
            
            loading.style.display = 'none';
            results.style.display = 'block';
        }
        
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = () => reject(new Error('파일 읽기 실패'));
                reader.readAsText(file);
            });
        }
        
        async function analyzeGPXFile(gpxContent, filename) {
            console.log('=== GPX 분석 시작 ===', filename);
            
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(gpxContent, "text/xml");
            
            const parseError = xmlDoc.getElementsByTagName("parsererror");
            if (parseError.length > 0) {
                throw new Error('GPX 파일 파싱 오류');
            }
            
            const trackpoints = extractTrackpoints(xmlDoc);
            console.log('추출된 트랙포인트:', trackpoints.length);
            
            if (trackpoints.length === 0) {
                throw new Error('유효한 트랙포인트가 없습니다');
            }
            
            const dataIntegrity = analyzeDataIntegrity(trackpoints);
            
            let detailedAnalysis = null;
            let fptScore = null;
            let challengeValidation = null;
            let segmentAnalysis = null;
            let uphillAnalysis = null;
            
            if (dataIntegrity.isValid) {
                detailedAnalysis = performDetailedAnalysis(trackpoints);
                fptScore = calculateFPTScore(detailedAnalysis);
                challengeValidation = validateChallengeRules(trackpoints, detailedAnalysis);
                segmentAnalysis = analyzeSegments(trackpoints);
                uphillAnalysis = calculateUphillDistance(trackpoints);
            }
            
            return {
                filename: filename,
                trackpointCount: trackpoints.length,
                trackpoints: trackpoints,
                dataIntegrity: dataIntegrity,
                detailedAnalysis: detailedAnalysis,
                fptScore: fptScore,
                challengeValidation: challengeValidation,
                segmentAnalysis: segmentAnalysis,
                uphillAnalysis: uphillAnalysis,
                isValid: dataIntegrity.isValid
            };
        }
        
        function extractTrackpoints(xmlDoc) {
            const trackpoints = [];
            
            const tracks = xmlDoc.getElementsByTagName('trk');
            for (let i = 0; i < tracks.length; i++) {
                const segments = tracks[i].getElementsByTagName('trkseg');
                for (let j = 0; j < segments.length; j++) {
                    const points = segments[j].getElementsByTagName('trkpt');
                    for (let k = 0; k < points.length; k++) {
                        const point = extractPointData(points[k]);
                        if (point) trackpoints.push(point);
                    }
                }
            }
            
            if (trackpoints.length < 10) {
                const waypoints = xmlDoc.getElementsByTagName('wpt');
                for (let i = 0; i < waypoints.length; i++) {
                    const point = extractPointData(waypoints[i]);
                    if (point) trackpoints.push(point);
                }
            }
            
            trackpoints.sort((a, b) => {
                if (!a.time || !b.time) return 0;
                return new Date(a.time) - new Date(b.time);
            });
            
            return trackpoints;
        }
        
        function extractPointData(pointElement) {
            const lat = parseFloat(pointElement.getAttribute('lat'));
            const lon = parseFloat(pointElement.getAttribute('lon'));
            
            if (isNaN(lat) || isNaN(lon)) return null;
            
            let elevation = null;
            const eleElement = pointElement.getElementsByTagName('ele')[0];
            if (eleElement) {
                elevation = parseFloat(eleElement.textContent);
            }
            
            let time = null;
            const timeElement = pointElement.getElementsByTagName('time')[0];
            if (timeElement) {
                try {
                    time = new Date(timeElement.textContent).toISOString();
                } catch (e) {
                    console.warn('시간 파싱 실패:', timeElement.textContent);
                }
            }
            
            return {
                latitude: lat,
                longitude: lon,
                elevation: elevation,
                time: time
            };
        }
        
        function analyzeDataIntegrity(trackpoints) {
            const totalPoints = trackpoints.length;
            let validTimeCount = 0;
            let validElevationCount = 0;
            let validSequenceCount = 0;
            
            for (let i = 0; i < trackpoints.length; i++) {
                if (trackpoints[i].time) {
                    validTimeCount++;
                    if (i > 0 && trackpoints[i-1].time) {
                        const time1 = new Date(trackpoints[i-1].time);
                        const time2 = new Date(trackpoints[i].time);
                        if (time2 > time1) {
                            validSequenceCount++;
                        }
                    }
                }
                if (trackpoints[i].elevation !== null && !isNaN(trackpoints[i].elevation)) {
                    validElevationCount++;
                }
            }
            
            const timeRatio = validTimeCount / totalPoints;
            const elevationRatio = validElevationCount / totalPoints;
            const sequenceRatio = validSequenceCount / Math.max(1, validTimeCount - 1);
            
            let isValid = false;
            let suspicionScore = 0;
            let verdict = "";
            let issues = [];
            
            if (timeRatio < 0.1) {
                suspicionScore += 90;
                issues.push("시간 정보 거의 없음 (프로그램 생성 확실)");
            } else if (timeRatio < 0.5) {
                suspicionScore += 60;
                issues.push("시간 정보 부족 (데이터 무결성 의심)");
            }
            
            if (sequenceRatio < 0.8 && validTimeCount > 1) {
                suspicionScore += 50;
                issues.push("시간 순서 불일치 (데이터 조작 의심)");
            }
            
            if (elevationRatio < 0.3) {
                suspicionScore += 30;
                issues.push("고도 정보 부족");
            }
            
            if (suspicionScore >= 80) {
                verdict = "🚨 가짜 파일 확실";
                isValid = false;
            } else if (suspicionScore >= 40) {
                verdict = "⚠️ 의심스러운 파일";
                isValid = false;
            } else {
                verdict = "✅ 실제 기록";
                isValid = true;
            }
            
            return {
                isValid: isValid,
                suspicionScore: suspicionScore,
                verdict: verdict,
                issues: issues,
                timeRatio: (timeRatio * 100).toFixed(1),
                elevationRatio: (elevationRatio * 100).toFixed(1),
                sequenceRatio: (sequenceRatio * 100).toFixed(1),
                validTimeCount: validTimeCount,
                validElevationCount: validElevationCount
            };
        }
        
        function calculateDistance(point1, point2) {
            const R = 6371;
            const lat1 = point1.latitude * Math.PI / 180;
            const lon1 = point1.longitude * Math.PI / 180;
            const lat2 = point2.latitude * Math.PI / 180;
            const lon2 = point2.longitude * Math.PI / 180;
            
            const dLat = lat2 - lat1;
            const dLon = lon2 - lon1;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1) * Math.cos(lat2) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function performDetailedAnalysis(trackpoints) {
            let totalDistance = 0;
            let totalElevationGain = 0;
            let totalElevationLoss = 0;
            let movingTime = 0;
            const speeds = [];
            
            for (let i = 1; i < trackpoints.length; i++) {
                const prev = trackpoints[i-1];
                const curr = trackpoints[i];
                
                const distance = calculateDistance(prev, curr);
                totalDistance += distance;
                
                if (prev.elevation !== null && curr.elevation !== null) {
                    const elevationChange = curr.elevation - prev.elevation;
                    if (Math.abs(elevationChange) > 0.5) {
                        if (elevationChange > 0) {
                            totalElevationGain += elevationChange;
                        } else {
                            totalElevationLoss += Math.abs(elevationChange);
                        }
                    }
                }
                
                if (prev.time && curr.time) {
                    const time1 = new Date(prev.time);
                    const time2 = new Date(curr.time);
                    const timeDiff = (time2 - time1) / 1000;
                    
                    if (timeDiff > 0 && timeDiff < 3600) {
                        movingTime += timeDiff;
                        if (distance > 0) {
                            const speed = (distance * 3600) / timeDiff;
                            if (speed < 100) {
                                speeds.push(speed);
                            }
                        }
                    }
                }
            }
            
            const elevations = trackpoints
                .map(p => p.elevation)
                .filter(e => e !== null && !isNaN(e));
            
            const maxElevation = elevations.length > 0 ? Math.max(...elevations) : 0;
            const minElevation = elevations.length > 0 ? Math.min(...elevations) : 0;
            const averageSpeed = speeds.length > 0 ? speeds.reduce((a, b) => a + b, 0) / speeds.length : 0;
            
            return {
                totalDistance: totalDistance,
                totalElevationGain: totalElevationGain,
                totalElevationLoss: totalElevationLoss,
                movingTime: movingTime,
                maxElevation: maxElevation,
                minElevation: minElevation,
                averageSpeed: averageSpeed,
                speedData: speeds
            };
        }
        
        function calculateFPTScore(analysis) {
            if (!analysis) return null;
            
            const distance = analysis.totalDistance;
            const elevationGain = analysis.totalElevationGain;
            
            let fptScore = Math.floor(distance * 10);
            
            if (elevationGain > 100) {
                fptScore += Math.floor(elevationGain / 10);
            }
            
            return {
                score: fptScore,
                breakdown: {
                    distance: Math.floor(distance * 10),
                    elevation: Math.floor(elevationGain / 10),
                    bonus: 0
                }
            };
        }
        
        function validateChallengeRules(trackpoints, analysis) {
            const rules = [];
            
            rules.push({
                name: "최소 거리 5km 이상",
                passed: analysis.totalDistance >= 5,
                actual: analysis.totalDistance.toFixed(2) + "km",
                required: "5km 이상"
            });
            
            rules.push({
                name: "최소 고도 상승 300m 이상",
                passed: analysis.totalElevationGain >= 300,
                actual: Math.round(analysis.totalElevationGain) + "m",
                required: "300m 이상"
            });
            
            const movingTimeHours = analysis.movingTime / 3600;
            rules.push({
                name: "최소 Moving Time 2시간 이상",
                passed: movingTimeHours >= 2,
                actual: formatDuration(analysis.movingTime),
                required: "2시간 이상"
            });
            
            rules.push({
                name: "평균 속도 적정성",
                passed: analysis.averageSpeed >= 1 && analysis.averageSpeed <= 15,
                actual: analysis.averageSpeed.toFixed(1) + "km/h",
                required: "1-15km/h 범위"
            });
            
            const allPassed = rules.every(rule => rule.passed);
            
            return {
                allRulesPassed: allPassed,
                rules: rules,
                overallStatus: allPassed ? "✅ 모든 규칙 통과" : "❌ 일부 규칙 미달"
            };
        }
        
        // 1km 구간별 분석
        function analyzeSegments(trackpoints) {
            const segments = [];
            let currentDistance = 0;
            let segmentStart = 0;
            let segmentDistance = 0;
            let segmentStartTime = null;
            let segmentStartElevation = null;
            
            for (let i = 1; i < trackpoints.length; i++) {
                const prev = trackpoints[i-1];
                const curr = trackpoints[i];
                
                const distance = calculateDistance(prev, curr);
                currentDistance += distance;
                segmentDistance += distance;
                
                if (segmentStartTime === null && prev.time) {
                    segmentStartTime = new Date(prev.time);
                }
                if (segmentStartElevation === null && prev.elevation !== null) {
                    segmentStartElevation = prev.elevation;
                }
                
                // 1km마다 구간 생성
                if (segmentDistance >= 1.0) {
                    const segmentEndTime = curr.time ? new Date(curr.time) : null;
                    const segmentEndElevation = curr.elevation;
                    
                    let duration = 0;
                    let averageSpeed = 0;
                    let elevationChange = 0;
                    
                    if (segmentStartTime && segmentEndTime) {
                        duration = (segmentEndTime - segmentStartTime) / 1000;
                        averageSpeed = duration > 0 ? (segmentDistance * 3600) / duration : 0;
                    }
                    
                    if (segmentStartElevation !== null && segmentEndElevation !== null) {
                        elevationChange = segmentEndElevation - segmentStartElevation;
                    }
                    
                    segments.push({
                        segmentNumber: segments.length + 1,
                        startKm: (currentDistance - segmentDistance).toFixed(1),
                        endKm: currentDistance.toFixed(1),
                        distance: segmentDistance.toFixed(2),
                        duration: duration,
                        averageSpeed: averageSpeed,
                        elevationChange: elevationChange,
                        startElevation: segmentStartElevation,
                        endElevation: segmentEndElevation
                    });
                    
                    // 다음 구간 준비
                    segmentDistance = 0;
                    segmentStartTime = segmentEndTime;
                    segmentStartElevation = segmentEndElevation;
                }
            }
            
            // 마지막 구간 (1km 미만)
            if (segmentDistance > 0.1) {
                const lastPoint = trackpoints[trackpoints.length - 1];
                const segmentEndTime = lastPoint.time ? new Date(lastPoint.time) : null;
                const segmentEndElevation = lastPoint.elevation;
                
                let duration = 0;
                let averageSpeed = 0;
                let elevationChange = 0;
                
                if (segmentStartTime && segmentEndTime) {
                    duration = (segmentEndTime - segmentStartTime) / 1000;
                    averageSpeed = duration > 0 ? (segmentDistance * 3600) / duration : 0;
                }
                
                if (segmentStartElevation !== null && segmentEndElevation !== null) {
                    elevationChange = segmentEndElevation - segmentStartElevation;
                }
                
                segments.push({
                    segmentNumber: segments.length + 1,
                    startKm: (currentDistance - segmentDistance).toFixed(1),
                    endKm: currentDistance.toFixed(1),
                    distance: segmentDistance.toFixed(2),
                    duration: duration,
                    averageSpeed: averageSpeed,
                    elevationChange: elevationChange,
                    startElevation: segmentStartElevation,
                    endElevation: segmentEndElevation
                });
            }
            
            return segments;
        }
        
        // 오르막 구간만 합산
        function calculateUphillDistance(trackpoints) {
            let uphillDistance = 0;
            let totalUphillElevation = 0;
            let uphillSegments = [];
            let currentUphillStart = null;
            let currentUphillDistance = 0;
            let currentUphillElevation = 0;
            
            const minGradient = 0.02; // 2% 경사 이상을 오르막으로 간주
            
            for (let i = 1; i < trackpoints.length; i++) {
                const prev = trackpoints[i-1];
                const curr = trackpoints[i];
                
                if (prev.elevation !== null && curr.elevation !== null) {
                    const distance = calculateDistance(prev, curr) * 1000; // 미터로 변환
                    const elevationChange = curr.elevation - prev.elevation;
                    const gradient = distance > 0 ? elevationChange / distance : 0;
                    
                    if (gradient >= minGradient && elevationChange > 0) {
                        // 오르막 구간
                        if (currentUphillStart === null) {
                            currentUphillStart = i - 1;
                            currentUphillDistance = 0;
                            currentUphillElevation = 0;
                        }
                        
                        uphillDistance += distance / 1000; // km로 다시 변환
                        currentUphillDistance += distance / 1000;
                        totalUphillElevation += elevationChange;
                        currentUphillElevation += elevationChange;
                    } else {
                        // 오르막 구간 종료
                        if (currentUphillStart !== null && currentUphillDistance > 0.05) { // 50m 이상인 구간만 기록
                            uphillSegments.push({
                                startIndex: currentUphillStart,
                                endIndex: i - 1,
                                distance: currentUphillDistance,
                                elevationGain: currentUphillElevation,
                                averageGradient: (currentUphillElevation / (currentUphillDistance * 1000) * 100).toFixed(1)
                            });
                        }
                        currentUphillStart = null;
                        currentUphillDistance = 0;
                        currentUphillElevation = 0;
                    }
                }
            }
            
            // 마지막 오르막 구간 처리
            if (currentUphillStart !== null && currentUphillDistance > 0.05) {
                uphillSegments.push({
                    startIndex: currentUphillStart,
                    endIndex: trackpoints.length - 1,
                    distance: currentUphillDistance,
                    elevationGain: currentUphillElevation,
                    averageGradient: (currentUphillElevation / (currentUphillDistance * 1000) * 100).toFixed(1)
                });
            }
            
            return {
                totalUphillDistance: uphillDistance,
                totalUphillElevation: totalUphillElevation,
                uphillSegments: uphillSegments,
                uphillPercentage: trackpoints.length > 1 ? (uphillDistance / calculateTotalDistance(trackpoints) * 100).toFixed(1) : 0
            };
        }
        
        function calculateTotalDistance(trackpoints) {
            let totalDistance = 0;
            for (let i = 1; i < trackpoints.length; i++) {
                totalDistance += calculateDistance(trackpoints[i-1], trackpoints[i]);
            }
            return totalDistance;
        }
        
        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            return hours + "시간 " + minutes + "분";
        }
        
        function formatTime(seconds) {
            if (seconds < 60) return seconds.toFixed(0) + "초";
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            if (minutes < 60) return minutes + "분 " + remainingSeconds + "초";
            const hours = Math.floor(minutes / 60);
            const remainingMinutes = minutes % 60;
            return hours + "시간 " + remainingMinutes + "분";
        }
        
        // 지도 생성 함수
        function createMap(trackpoints, containerId) {
            if (trackpoints.length === 0) return null;
            
            // 기존 지도 제거
            if (currentMap) {
                currentMap.remove();
                currentMap = null;
            }
            
            // 경계 계산
            const lats = trackpoints.map(p => p.latitude);
            const lngs = trackpoints.map(p => p.longitude);
            const minLat = Math.min(...lats);
            const maxLat = Math.max(...lats);
            const minLng = Math.min(...lngs);
            const maxLng = Math.max(...lngs);
            
            // 지도 생성
            const map = L.map(containerId).fitBounds([
                [minLat, minLng],
                [maxLat, maxLng]
            ]);
            
            // 타일 레이어 추가
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(map);
            
            // 경로 그리기
            const routeCoords = trackpoints.map(p => [p.latitude, p.longitude]);
            const routeLine = L.polyline(routeCoords, {
                color: '#e74c3c',
                weight: 4,
                opacity: 0.8
            }).addTo(map);
            
            // 시작점 마커
            L.marker([trackpoints[0].latitude, trackpoints[0].longitude])
                .bindPopup('🏁 시작점')
                .addTo(map);
            
            // 끝점 마커
            const lastPoint = trackpoints[trackpoints.length - 1];
            L.marker([lastPoint.latitude, lastPoint.longitude])
                .bindPopup('🏃 끝점')
                .addTo(map);
            
            currentMap = map;
            return map;
        }
        
        // 고도 차트 생성 함수
        function createElevationChart(trackpoints, containerId) {
            const canvas = document.getElementById(containerId);
            if (!canvas) return null;
            
            const ctx = canvas.getContext('2d');
            
            // 기존 차트 제거
            if (currentElevationChart) {
                currentElevationChart.destroy();
                currentElevationChart = null;
            }
            
            // 거리와 고도 데이터 계산
            let cumulativeDistance = 0;
            const chartData = [];
            
            for (let i = 0; i < trackpoints.length; i++) {
                const point = trackpoints[i];
                
                if (i > 0) {
                    const distance = calculateDistance(trackpoints[i-1], point);
                    cumulativeDistance += distance;
                }
                
                if (point.elevation !== null) {
                    chartData.push({
                        x: cumulativeDistance,
                        y: point.elevation
                    });
                }
            }
            
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: '고도 (m)',
                        data: chartData,
                        borderColor: '#27ae60',
                        backgroundColor: 'rgba(39, 174, 96, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: '거리 (km)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '고도 (m)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `거리: ${context.parsed.x.toFixed(2)}km, 고도: ${context.parsed.y.toFixed(0)}m`;
                                }
                            }
                        }
                    }
                }
            });
            
            currentElevationChart = chart;
            return chart;
        }
        
        function displayResults(analysisResults) {
            let html = '';
            
            for (const result of analysisResults) {
                html += generateResultCard(result);
            }
            
            results.innerHTML = html;
            
            // 지도와 차트 생성 (첫 번째 유효한 결과에 대해서만)
            const validResult = analysisResults.find(r => r.isValid && r.trackpoints);
            if (validResult) {
                // 지도 생성을 위한 딜레이
                setTimeout(() => {
                    try {
                        createMap(validResult.trackpoints, 'map');
                        createElevationChart(validResult.trackpoints, 'elevationChart');
                    } catch (error) {
                        console.error('지도 또는 차트 생성 오류:', error);
                    }
                }, 100);
            }
        }
        
        function generateResultCard(result) {
            if (result.error) {
                return `
                    <div class="result-card">
                        <div class="result-title">❌ ${result.filename}</div>
                        <div class="error-message">
                            오류: ${result.error}
                        </div>
                    </div>
                `;
            }
            
            let html = `
                <div class="result-card">
                    <div class="result-title">📊 ${result.filename}</div>
                    
                    <div class="verification-result ${getVerificationClass(result.dataIntegrity)}">
                        <div class="score-display">${result.dataIntegrity.verdict}</div>
                        <p><strong>의심 점수:</strong> ${result.dataIntegrity.suspicionScore}/100</p>
                        <p><strong>트랙포인트:</strong> ${result.trackpointCount}개</p>
                        <p><strong>시간 정보:</strong> ${result.dataIntegrity.timeRatio}%</p>
                        <p><strong>고도 정보:</strong> ${result.dataIntegrity.elevationRatio}%</p>
                        ${result.dataIntegrity.issues.length > 0 ? 
                            '<p><strong>문제점:</strong> ' + result.dataIntegrity.issues.join(', ') + '</p>' : ''}
                    </div>
            `;
            
            if (result.isValid && result.detailedAnalysis) {
                html += generateDetailedResults(result);
            }
            
            html += '</div>';
            return html;
        }
        
        function generateDetailedResults(result) {
            const analysis = result.detailedAnalysis;
            const segments = result.segmentAnalysis || [];
            const uphill = result.uphillAnalysis || {};
            
            let html = '';
            
            // FPT 점수
            if (result.fptScore) {
                html += `
                    <div class="fpt-score">
                        <h3>🏆 FPT 점수</h3>
                        <div class="score">${result.fptScore.score}</div>
                        <p>거리: ${result.fptScore.breakdown.distance}점 + 고도: ${result.fptScore.breakdown.elevation}점</p>
                    </div>
                `;
            }
            
            // 지도
            html += `
                <div style="margin-bottom: 30px;">
                    <h3 style="margin-bottom: 15px; color: #2c3e50;">🗺️ 등산 경로</h3>
                    <div id="map"></div>
                </div>
            `;
            
            // 고도 차트
            html += `
                <div class="elevation-chart-container">
                    <h3>📈 고도 변화 차트</h3>
                    <div style="height: 300px;">
                        <canvas id="elevationChart"></canvas>
                    </div>
                </div>
            `;
            
            // 오르막 구간 분석
            if (uphill.totalUphillDistance !== undefined) {
                html += `
                    <div class="uphill-summary">
                        <h3>⛰️ 오르막 구간 전용 분석</h3>
                        <div class="uphill-stats">
                            <div class="uphill-stat">
                                <span class="value">${uphill.totalUphillDistance.toFixed(2)}</span>
                                <span class="label">오르막 거리 (km)</span>
                            </div>
                            <div class="uphill-stat">
                                <span class="value">${uphill.totalUphillElevation.toFixed(0)}</span>
                                <span class="label">오르막 고도상승 (m)</span>
                            </div>
                            <div class="uphill-stat">
                                <span class="value">${uphill.uphillPercentage}%</span>
                                <span class="label">오르막 비율</span>
                            </div>
                            <div class="uphill-stat">
                                <span class="value">${uphill.uphillSegments.length}</span>
                                <span class="label">오르막 구간 수</span>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // 1km 구간별 분석
            if (segments.length > 0) {
                html += `
                    <div class="segment-analysis">
                        <h3>📏 1km 구간별 상세 분석</h3>
                        <div class="segment-item segment-header">
                            <div>구간</div>
                            <div>거리 범위</div>
                            <div>소요시간</div>
                            <div>평균속도</div>
                            <div>고도변화</div>
                            <div>구간거리</div>
                        </div>
                `;
                
                segments.forEach(segment => {
                    html += `
                        <div class="segment-item">
                            <div>${segment.segmentNumber}구간</div>
                            <div>${segment.startKm} - ${segment.endKm}km</div>
                            <div>${formatTime(segment.duration)}</div>
                            <div>${segment.averageSpeed.toFixed(1)} km/h</div>
                            <div>${segment.elevationChange > 0 ? '+' : ''}${segment.elevationChange.toFixed(0)}m</div>
                            <div>${segment.distance}km</div>
                        </div>
                    `;
                });
                
                html += '</div>';
            }
            
            // 상세 데이터
            html += `
                <div class="data-grid">
                    <div class="data-item">
                        <div class="data-label">총 거리</div>
                        <div class="data-value">${analysis.totalDistance.toFixed(2)} km</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">고도 상승</div>
                        <div class="data-value">${Math.round(analysis.totalElevationGain)} m</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">고도 하강</div>
                        <div class="data-value">${Math.round(analysis.totalElevationLoss)} m</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">최고 고도</div>
                        <div class="data-value">${Math.round(analysis.maxElevation)} m</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">최저 고도</div>
                        <div class="data-value">${Math.round(analysis.minElevation)} m</div>
                    </div>
                    <div class="data-item">
                        <div class="data-label">평균 속도</div>
                        <div class="data-value">${analysis.averageSpeed.toFixed(1)} km/h</div>
                    </div>
                </div>
            `;
            
            // 챌린지 규칙 검증
            if (result.challengeValidation) {
                const challenge = result.challengeValidation;
                html += `
                    <div style="background: #f8f9ff; border-radius: 15px; padding: 25px; margin-top: 25px; border: 2px solid #6c5ce7;">
                        <h3 style="color: #5a4fcf; margin-bottom: 20px; font-size: 1.4em;">🎯 탄젠트 마스터 챌린지 규칙 검증</h3>
                        <div style="text-align: center; margin-bottom: 20px;">
                            <strong style="font-size: 1.2em; color: ${challenge.allRulesPassed ? '#28a745' : '#dc3545'};">
                                ${challenge.overallStatus}
                            </strong>
                        </div>
                        ${challenge.rules.map(rule => `
                            <div style="display: flex; align-items: center; margin-bottom: 15px; padding: 12px; background: white; border-radius: 10px;">
                                <div style="width: 25px; height: 25px; border-radius: 50%; margin-right: 15px; display: flex; align-items: center; justify-content: center; font-weight: bold; color: white; font-size: 0.9em; background: ${rule.passed ? '#28a745' : '#dc3545'};">
                                    ${rule.passed ? '✓' : '✗'}
                                </div>
                                <div>
                                    <strong>${rule.name}</strong><br>
                                    실제: ${rule.actual} | 요구: ${rule.required}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            return html;
        }
        
        function getVerificationClass(dataIntegrity) {
            if (dataIntegrity.suspicionScore >= 80) return 'verification-fake';
            if (dataIntegrity.suspicionScore >= 40) return 'verification-suspicious';
            return 'verification-authentic';
        }
        
        // 샘플 데이터 생성
        function generateSampleGPX(filename) {
            const startLat = 37.6556;
            const startLon = 126.9924;
            let startEle = 300;
            const startTime = new Date('2024-01-15T09:00:00Z');
            
            let gpxContent = '<?xml version="1.0" encoding="UTF-8"?>\n';
            gpxContent += '<gpx version="1.1" creator="BeneFit App">\n';
            gpxContent += '    <trk>\n';
            gpxContent += '        <name>실제 등산 기록</name>\n';
            gpxContent += '        <trkseg>\n';
            
            let lat = startLat;
            let lon = startLon;
            let elevation = startEle;
            let timestamp = new Date(startTime);
            
            const pointCount = 500; // 더 많은 포인트로 상세한 경로 생성
            
            for (let i = 0; i < pointCount; i++) {
                const progress = i / pointCount;
                
                // 고도 변화 (산의 형태를 시뮬레이션)
                let elevationTrend = 0;
                if (progress < 0.3) {
                    // 초반 완만한 오르막
                    elevationTrend = 2 + Math.random() * 3;
                } else if (progress < 0.6) {
                    // 중반 가파른 오르막
                    elevationTrend = 4 + Math.random() * 5;
                } else if (progress < 0.8) {
                    // 정상 부근 완만한 오르막
                    elevationTrend = 1 + Math.random() * 2;
                } else {
                    // 하산 구간
                    elevationTrend = -(2 + Math.random() * 4);
                }
                
                const terrain = Math.sin(progress * Math.PI * 8) * 2; // 지형의 기복
                const noise = (Math.random() - 0.5) * 3; // GPS 노이즈
                elevation += elevationTrend + terrain + noise;
                
                // 시간 간격 (15-45초)
                const interval = 15 + Math.random() * 30;
                timestamp = new Date(timestamp.getTime() + interval * 1000);
                
                // 위치 변화
                const baseSpeed = 2 + Math.random() * 3; // 2-5 km/h
                const distanceKm = (baseSpeed * interval) / 3600;
                const distanceDeg = distanceKm / 111;
                
                const direction = (progress * Math.PI * 3) + (Math.random() - 0.5) * 0.3;
                lat += Math.cos(direction) * distanceDeg + (Math.random() - 0.5) * 0.0001;
                lon += Math.sin(direction) * distanceDeg + (Math.random() - 0.5) * 0.0001;
                
                // 가끔 휴식 구간 추가
                if (Math.random() < 0.02) {
                    for (let rest = 0; rest < 15; rest++) {
                        gpxContent += `            <trkpt lat="${lat.toFixed(6)}" lon="${lon.toFixed(6)}">\n`;
                        gpxContent += `                <ele>${elevation.toFixed(1)}</ele>\n`;
                        gpxContent += `                <time>${timestamp.toISOString()}</time>\n`;
                        gpxContent += `            </trkpt>\n`;
                        timestamp = new Date(timestamp.getTime() + 20000); // 20초 간격
                    }
                    continue;
                }
                
                gpxContent += `            <trkpt lat="${lat.toFixed(6)}" lon="${lon.toFixed(6)}">\n`;
                gpxContent += `                <ele>${elevation.toFixed(1)}</ele>\n`;
                gpxContent += `                <time>${timestamp.toISOString()}</time>\n`;
                gpxContent += `            </trkpt>\n`;
            }
            
            gpxContent += '        </trkseg>\n';
            gpxContent += '    </trk>\n';
            gpxContent += '</gpx>';
            
            return {
                filename: filename,
                content: gpxContent
            };
        }
        
        function loadSampleData() {
            console.log('샘플 데이터 로드 시작');
            
            try {
                const sampleFile = generateSampleGPX('샘플_등산_기록.gpx');
                
                loading.style.display = 'block';
                results.style.display = 'none';
                
                setTimeout(async () => {
                    try {
                        const analysis = await analyzeGPXFile(sampleFile.content, sampleFile.filename);
                        displayResults([analysis]);
                    } catch (error) {
                        console.error('샘플 데이터 분석 오류:', error);
                        displayResults([{
                            filename: sampleFile.filename,
                            error: error.message,
                            isValid: false
                        }]);
                    }
                    loading.style.display = 'none';
                    results.style.display = 'block';
                }, 1500);
                
            } catch (error) {
                console.error('샘플 데이터 로드 오류:', error);
                alert('샘플 데이터 생성 중 오류가 발생했습니다: ' + error.message);
                loading.style.display = 'none';
            }
        }
        
        console.log('고급 GPX 분석기 초기화 완료');
    </script>
</body>
</html>